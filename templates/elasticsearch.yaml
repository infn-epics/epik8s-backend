apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: elasticsearch
  namespace: argocd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: 'registry-1.docker.io/bitnamicharts'  # Bitnami Helm repo
    targetRevision: {{.Values.elasticsearch.targetRevision}}
    chart: elasticsearch
    helm:
      values: |
        image:
          repository: {{ .Values.elasticsearch.image.repository }}
          tag: {{ .Values.elasticsearch.image.tag }}
        kibanaEnabled: {{.Values.elasticsearch.kibanaEnabled}}
        # Add master, data, metrics, kibana images from values.yaml
        master:
          image:
            repository: {{ .Values.elasticsearch.master.image.repository }}
            tag: {{ .Values.elasticsearch.master.image.tag }}
        data:
          image:
            repository: {{ .Values.elasticsearch.data.image.repository }}
            tag: {{ .Values.elasticsearch.data.image.tag }}
        metrics:
          image:
            repository: {{ .Values.elasticsearch.metrics.image.repository }}
            tag: {{ .Values.elasticsearch.metrics.image.tag }}
        kibana:
          image:
            repository: {{ .Values.elasticsearch.kibana.image.repository }}
            tag: {{ .Values.elasticsearch.kibana.image.tag }}
        global:
            
          {{- if .Values.openshift }}
          compatibility:
            openshift:
                adaptSecurityContext: enabled
          {{- end }}
        clusterName: elastic
        
        master:
          {{- if .Values.elasticsearch.resources }}
          resources:
{{ toYaml .Values.elasticsearch.resources | indent 10 }}
          {{- end }}

          networkPolicy:
            enabled: false
          ingress:
            enabled: true
            hostname: elasticsearch.{{.Values.domain}}
            path: /
            {{- if .Values.ingressClassName }}
            ingressClassName: {{.Values.ingressClassName }}
            {{- end }}
          masterOnly: false
          replicaCount: {{.Values.elasticsearch.replicaCount}}
          {{- if .Values.openshift }}
          serviceAccount:
            name: "default"
            create: false
          {{- end }}
          persistence:
            size: {{ .Values.size }}
        data:
          replicaCount: 0
        coordinating:
          replicaCount: 0
        ingest:
          replicaCount: 0
        security:
          enabled: false
          # PASSWORD must be the same value passed to elasticsearch to get an "out of the box" experience
          elasticPassword: "epics"
          tls:
            # AutoGenerate TLS certs for elastic
            autoGenerated: true
            enable: false

        kibana:
          ingress:
            enabled: true
            hostname: kibana.{{.Values.domain}}
            path: /
            ingressClassName: {{.Values.ingressClassName }}
          {{- if .Values.openshift }}
          serviceAccount:
            name: "default"
            create: false
          {{- end }}
          ##
          networkPolicy:
            enabled: false
          elasticsearch:
            host:
              - elasticsearch.backend.svc.cluster.local
            security:
              auth:
                enabled: true
                # default in the elasticsearch chart is elastic
                kibanaUsername: "epics"
                kibanaPassword: "epics"
              tls:
                # Instruct kibana to connect to elastic over https
                enabled: false
                # Bit of a catch 22, as you will need to know the name upfront of your release
                existingSecret: elasticsearch-master-crt # or elasticsearch-coordinating-crt' if the release name happens to be 'elasticsearch'
                # As the certs are auto-generated, they are pemCerts so set to true
                usePemCerts: true
        
        
        
          
          
  destination:
    server: https://kubernetes.default.svc
    namespace: {{ .Values.namespace | quote }}
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
  

